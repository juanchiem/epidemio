[["index.html", "Epidemiologia de enfermedades de cultivos", " Epidemiologia de enfermedades de cultivos Juan Edwards Objetivos Familiarizar al alumnado con herramientas del software R para diferentes técnicasd de modelado de epidemias de enfermedades de cultivos agrícolas. Destinatarios Fitopatólogos, con previos conocimientos sobre manipaulación de datos fitopatométricos en R. Motivación Las epidemias son potentes armas en la “guerra” contra quién nos enfrentamos año tras año por mantener la sanidad de nuestros cultivos. La industria química y de semillas nos proveen buenas tácticas de defensa pero solo la epidemiología nos permite planear la estrategia. Nuestra defensa en tiempos de guerra está relacionada al tratamiento que damos a nuestros cultivos en tiempos de paz. — J.E. Vanderplank, Sudáfrica, 1963 * Fuente: Open Plant Pathology "],["1_1-comparar_curvas.html", "1 Curvas de progreso", " 1 Curvas de progreso library(ggplot2) theme_set(theme_minimal()) Definición matemática de los modelos logistico, gompertz e monomolecular (2 parametros) lo2 &lt;- function(x, y0, r) { 1 / (1 + ((1 - y0) / y0) * exp(-r * x)) } go2 &lt;- function(x, y0, r) { exp(log(y0) * exp(-r * x))} mo2 &lt;- function(x, y0, r) {1 - ((1 - y0) * exp(-r * x))} Graficar los 3 modelos con los mismos coeficientes param1 = list(y0=0.01, r=0.3) ggplot(data = data.frame(x = 0), aes(x = x))+ stat_function(fun=lo2, args=param1, aes(colour=&quot;Logístico&quot;)) + stat_function(fun=go2, args=param1, aes(colour=&quot;Gompertz&quot;)) + stat_function(fun=mo2, args=param1, aes(colour=&quot;Monomolecular&quot;)) + xlim(0,25) + ylim(0,1) + scale_colour_manual(&quot;Modelo&quot;, values = c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;)) La predicción para \\(t=15\\) para los 3 modelos seria: lo2(15, 0.01, 0.3) go2(15, 0.01, 0.3) mo2(15, 0.01, 0.3) ggplot(data = data.frame(x = 0), aes(x = x))+ stat_function(fun=lo2, args=param1, aes(colour=&quot;Logístico&quot;)) + stat_function(fun=go2, args=param1, aes(colour=&quot;Gompertz&quot;)) + stat_function(fun=mo2, args=param1, aes(colour=&quot;Monomolecular&quot;)) + scale_colour_manual(&quot;Modelo&quot;, values = c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;)) + xlim(0,25) + ylim(0,1) + geom_point(aes(x=15, y=lo2(15, 0.01, 0.3)))+ geom_point(aes(x=15, y=go2(15, 0.01, 0.3)))+ geom_point(aes(x=15, y=mo2(15, 0.01, 0.3))) Definición matemática de los modelos logistico, gompertz e monomolecular (3 parametros) lo3 &lt;- function(x, K, y0, r) {K/(1+((K-y0)/y0)*exp(-r*x))} go3 &lt;- function(x, K, y0, r) {K*(exp(-exp(y0-r*x)))} mo3 &lt;- function(x, K, y0, r) {K-(K-y0)*exp(-r*x)} Graficar los 3 modelos con los mismos coeficientes param2 = list(K=0.8, y0=0.01, r=0.3) ggplot(data = data.frame(x = 0), aes(x = x))+ stat_function(fun=lo3, args=param2, aes(colour=&quot;Logístico&quot;)) + stat_function(fun=go3, args=param2, aes(colour=&quot;Gompertz&quot;)) + stat_function(fun=mo3, args=param2, aes(colour=&quot;Monomolecular&quot;)) + xlim(0,25) + ylim(0,1) + scale_colour_manual(&quot;Modelo&quot;, values = c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;)) La predicción para \\(t=15\\) para los 3 modelos seria: lo3(15, 0.8, 0.01, 0.3) go3(15, 0.8, 0.01, 0.3) mo3(15, 0.8, 0.01, 0.3) Graficar dos curvas logisticas con igual \\(r\\) (0.5) pero diferente \\(k\\) (0.6 y 0.8): param3 = list(K=0.6, y0=0.01, r=0.5) param4 = list(K=0.8, y0=0.01, r=0.5) ggplot(data = data.frame(t = 0), aes(x = t))+ stat_function(fun = lo3, args=param3, aes(colour = &quot;r=0.5;k=0.6&quot;)) + stat_function(fun = lo3, args=param4, aes(colour = &quot;r=0.5;k=0.8&quot;)) + xlim(0,25) + ylim(0,1) + scale_colour_manual(&quot;Modelo \\nLogístico&quot;, values = c(&quot;red&quot;, &quot;blue&quot;)) Ahora, lo contrario, dos curvas logisticas con diferente \\(r\\) (0.3 y 0.6) e igual \\(k\\) (0.8): param5 = list(K=0.8, y0=0.01, r=0.4) param6 = list(K=0.8, y0=0.01, r=0.6) ggplot(data = data.frame(t = 0), aes(x = t))+ stat_function(fun = lo3, args=param5, aes(colour = &quot;r=0.4;k=0.8&quot;)) + stat_function(fun = lo3, args=param6, aes(colour = &quot;r=0.6;k=0.8&quot;)) + xlim(0,25) + ylim(0,1) + scale_colour_manual(&quot;Modelo \\nLogístico&quot;, values = c(&quot;red&quot;,&quot;blue&quot;)) "],["1_2-logistico_aplicado.html", "2 Logístico aplicado", " 2 Logístico aplicado library(tidyverse) # Definición matemática de los modelos logistico, gompertz e monomolecular lo &lt;- function(x, K, y0, r) {K/(1+((K-y0)/y0)*exp(-r*x))} Establezcamos el periodo critico plot_base &lt;- ggplot(data = data.frame(t = 0), aes(x = t))+ annotate(&quot;rect&quot;, xmin = 20, xmax = 40, ymin = 0, ymax = 100, alpha = .2)+ labs(y=&quot;Incidencia %&quot;)+ xlim(0,40) + theme_minimal()+ scale_y_continuous(limits = c(0,100), breaks = scales::pretty_breaks(5)) plot_base Curva logistica de referencia de manchas sin intervencion r =.5 param_ref = list(K=70, y0=0.01, r=.5) plot_base + stat_function(fun = lo, args=param_ref, col=&quot;red&quot;) ggsave(last_plot(), file = &quot;curva_ref.png&quot;, w=6, h=4) Efecto cultivar param_montoya = list(K=60, y0=0.01, r=.3) plot_base + stat_function(fun = lo, args=param_ref, col=&quot;red&quot;) + stat_function(fun = lo, args=param_montoya, col=&quot;blue&quot;) # ggsave(last_plot(), file = &quot;resistencia.png&quot;, w=6, h=4, dpi=600, scale = .8) Efecto ambiente # param_ref = list(K=60, y0=0.01, r=.5) param_lluvioso = list(K=70, y0=0.01, r=.6) param_seco = list(K=60, y0=0.01, r=.2) plot_base + # stat_function(fun = lo, args=param_ref, col=&quot;blue&quot;) + stat_function(fun = lo, args=param_lluvioso, col=&quot;red&quot;)+ stat_function(fun = lo, args=param_seco, col=&quot;green&quot;) ggsave(last_plot(), file = &quot;ambiente.png&quot;, w=6, h=4, dpi=600, scale = .8) Aplicamos un fungicida mezcla triazoles y disminuimos la tasa de progreso a .3 param_fungicida1 = list(K=60, y0=0.01, r=.3) param_fungicida2 = list(K=60, y0=0.01, r=.2) plot_base + stat_function(fun = lo, args=param_ref, col=&quot;red&quot;) + stat_function(fun = lo, args=param_fungicida1, col=&quot;blue&quot;) + stat_function(fun = lo, args=param_fungicida2, col=&quot;green&quot;) ggsave(last_plot(), file = &quot;fungicidas.png&quot;, w=6, h=4, dpi=600, scale = .8) Aplicamos un fungicida mezcla triple y disminuimos la tasa de progreso a .2 param_fungicida2 = list(K=60, y0=0.01, r=.2) plot_base + stat_function(fun = lo, args=param_ref, col=&quot;red&quot;) + stat_function(fun = lo, args=param_fungicida1, col=&quot;blue&quot;) ggsave(last_plot(), file = &quot;curva_mezcla.png&quot;, w=6, h=4, dpi=600, scale = .8) "],["1_3-epifitter.html", "3 Epifitter 3.1 Estimating K (maximum disease) 3.2 Fit models to multiple DPCs", " 3 Epifitter Kaique dos S. Alves and Emerson M. Del Ponte (2020). epifitter: Analysis and Simulation of Plant Disease Progress Curves. R package version 0.2.0. URL: https://CRAN.R-project.org/package=epifitter. library(tidyverse) library(epifitter) browseURL(&quot;https://alvesks.github.io/epifitter/articles/fitting.html&quot;) browseURL(&quot;https://emdelponte.github.io/epidemiology-R/temporal-analysis.html#model-fitting&quot;) dpcL &lt;- sim_logistic( N = 100, # duration of the epidemics in days y0 = 0.01, # disease intensity at time zero dt = 10, # interval between assessments r = 0.1, # apparent infection rate alpha = 0.2, # level of noise n = 7 # number of replicates ) dpcL dpcL %&gt;% ggplot()+ aes(time, y, group = replicates) + geom_point(aes(time, random_y), shape = 1) + # plot the replicate values geom_point(color = &quot;steelblue&quot;, size = 2) + geom_line(color = &quot;steelblue&quot;) + labs( title = &quot;Simulated &#39;complete&#39; epidemics of sigmoid shape&quot;, subtitle = &quot;Produced using sim_logistic()&quot; )+ theme_minimal() f_lin &lt;- fit_lin(time = dpcL$time, y = dpcL$random_y) f_lin head(f_lin$data) Plot of predictions The plot_fit() produces, by default, a panel of plots depicting the observed and predicted values by all fitted models. The arguments pont_size and line_size that control for the size of the dots for the observation and the size of the fitted line, respectively. plot_lin &lt;- plot_fit(f_lin, point_size = 2, line_size = 1 ) # Default plots plot_lin Two-parameters The fit_nlin() function uses the Levenberg-Marquardt algorithm for least-squares estimation of nonlinear parameters. In addition to time and disease intensity, starting values for y0 and r should be given in the starting_par argument. The output format and interpretation is analogous to the fit_lin(). NOTE: If you encounter error messages saying “matrix at initial parameter estimates”, try to modify the starting values for the parameters to solve the problem. f_nlin &lt;- fit_nlin( time = dpcL$time, y = dpcL$random_y, starting_par = list(y0 = 0.01, r = 0.03) ) f_nlin plot_fit(f_nlin) + theme_minimal()#changing plot theme 3.1 Estimating K (maximum disease) In many epidemics the last measure (final time) of a DPC does not reach the maximum intensity and, for this reason, estimation of maximum asymptote (carrying capacity K) may be necessary. The fin_lin2() provides an estimation of K in addition to the estimates provided by fit_lin(). Before demonstrating the function, we can transform our simulated data by creating another variable with y_random2 with maximum about 0.8 (80%). Simplest way is to multiply the y_random by 0.8. dpcL %&gt;% mutate(random_y = random_y * 0.8) -&gt; dpcL2 dpcL2 Then we run the fit_nlin2() for the new dataset. f_nlin2 &lt;- fit_nlin2( time = dpcL2$time, y = dpcL2$random_y, starting_par = list(y0 = 0.01, r = 0.2, K = 0.6) ) f_nlin2 plot_fit(f_nlin2) 3.2 Fit models to multiple DPCs Most commonly, there are more than one epidemics to analyse either from observational or experimental studies. When the goal is to fit a common model to all curves, the fit_multi() function is in hand. Each DPC needs an unique identified to further combined in a single data frame. Data Let’s use the sim_ family of functions to create three epidemics and store the data in a single data.frame. The Gompertz model was used to simulate these data. Note that we allowed to the y0 and r parameter to differ the DPCs. We should combine the three DPCs using the bind_rows() function and name the identifier (.id), automatically created as a character vector, for each epidemics as ‘DPC’. epi1 &lt;- sim_gompertz(N = 60, y0 = 0.001, dt = 5, r = 0.1, alpha = 0.4, n = 4) epi2 &lt;- sim_gompertz(N = 60, y0 = 0.001, dt = 5, r = 0.12, alpha = 0.4, n = 4) epi3 &lt;- sim_gompertz(N = 60, y0 = 0.003, dt = 5, r = 0.14, alpha = 0.4, n = 4) multi_epidemic &lt;- bind_rows(epi1, epi2, epi3, .id = &quot;DPC&quot; ) head(multi_epidemic) We can visualize the three DPCs in a same plot multi_epidemic %&gt;% ggplot()+ aes(time, y, col = DPC)+ geom_point(size =2)+ geom_line()+ theme_minimal() + labs(x = &quot;Time&quot;, y = &quot;Proportion disease&quot;) -&gt; p_multi p_multi p_multi + facet_wrap(~ DPC, ncol = 1) Using fit_multi() fit_multi() requires at least four arguments: time, disease intensity (as proportion), data and the curve identifier (strata_cols). The latter argument accepts one or more strata include as c(“strata1”,strata2\"). In the example below, the stratum name is DPC, the name of the variable. By default, the linear regression is fitted to data but adding another argument nlin = T, the non linear regressions is fitted instead. multi_fit &lt;- fit_multi( time_col = &quot;time&quot;, intensity_col = &quot;random_y&quot;, data = multi_epidemic, strata_cols = &quot;DPC&quot; ) head(multi_fit$Parameters, n=Inf) multi_fit2 &lt;- fit_multi( time_col = &quot;time&quot;, intensity_col = &quot;random_y&quot;, data = multi_epidemic, strata_cols = &quot;DPC&quot;, nlin = TRUE) head(multi_fit2$Parameters) multi_fit_K &lt;- fit_multi( time_col = &quot;time&quot;, intensity_col = &quot;random_y&quot;, data = multi_epidemic, strata_cols = &quot;DPC&quot;, nlin = T, estimate_K = T ) head(multi_fit_K$Parameters) multi_fit$Data %&gt;% ggplot(aes(time, predicted, color = DPC)) + geom_point(aes(time, y), color = &quot;gray&quot;) + geom_line(size = 1) + facet_grid(DPC ~ model, scales = &quot;free_y&quot;) + theme_minimal()+ coord_cartesian(ylim = c(0, 1)) multi_fit$Data %&gt;% filter(model == &quot;Gompertz&quot;) %&gt;% ggplot(aes(time, y=predicted, color = DPC)) + geom_point(aes(time, y), size = 2, alpha=.3) + geom_line(size = 1.2) + theme_minimal() + labs(x = &quot;Time&quot;, y = &quot;Disease Intensity&quot;) Apparent infection rate The multi_fit$Parameters element is where all stats and parameters as stored. Let’s plot the estimates of the apparent infection rate. multi_fit$Parameters %&gt;% filter(model == &quot;Gompertz&quot;) %&gt;% ggplot(aes(DPC, r)) + geom_point(size = 3) + geom_errorbar(aes(ymin = r_ci_lwr, ymax = r_ci_upr), width = 0, size = 1 ) + labs( x = &quot;Time&quot;, y = &quot;Apparent infection rate&quot; ) + theme_minimal() "],["2_1-epicrop.html", "4 Epicrop 4.1 Predict bacterial blight - wet season 4.2 Predict leaf blast - wet season 4.3 Comparando epidemias", " 4 Epicrop Autor: Adam H. Sparks pacman::p_load(&quot;epifitter&quot;, &quot;tidyverse&quot;) epicrop provee un paquete del modelo ‘EPIRICE’(Savary et al. 2012), el cual se basa en la prediccion de enfermedad por medio de modelo SEIR (Susceptible-Exposed-Infectious-Removed Cinco enfermedades de arroz (sin ningun manejo) se pueden modelar con las funciones: bacterial blight (predict_bacterial_blight()) brown spot (predict_brown_spot()) leaf blast (predict_leaf_blast()) sheath blight (predict_sheath_blight()) tungro (predict_tungro()) El modelo utiliza datos meteorológicos diarios para estimar la intensidad de la enfermedad. La funcion, get_wth() permite descargar datos meteorológicos de NASA POWER API, listos para ser usados en epicrop. El uso de las funciones del paquete está diseñado para ser sencillo para modelar los riesgos de enfermedades del arroz, pero lo suficientemente flexible para adaptarse a otros patosistemas que utilizan la función SEIR(). Si está interesado en modelar otros patosistemas, consulte Savary et al. (2012) para el desarrollo de los parámetros que se utilizaron para las enfermedades del arroz según se derivan de la literatura existente y se implementan en las funciones del modelo de enfermedad individual. Inicio Cargue el paquete library(&quot;epicrop&quot;) Obtener datos meteorológicos NOTA: hubieron varios casos de error en la instalación de epicrop, algunos de los cuales se resolvieron con la instalacion de Rtools, de acuerdo a los mensajes de error que salian en la consola. # correr solo en caso que no ande el siguiente chunk installr::install.Rtools() # Fetch weather for year 2000 season at the IRRI Zeigler Experiment Station wth &lt;- get_wth( # lonlat = c(-58.25614, -37.84632), # Balcarce lonlat = c(121.25562, 14.6774), dates = c(&quot;2000-01-01&quot;, &quot;2000-12-31&quot;) ) wth Otras vias de importación de datos desde archivos locales. Sirve de ejemplo de como deberian ser nuestros datos en caso que usemos de una estacion meteorológica local. wth &lt;- readr::read_csv(&quot;data/chirps.csv&quot;) 4.1 Predict bacterial blight - wet season Todas las funciones de la familia predict _ () funcionan exactamente de la misma manera. Se le proporciona datos meteorológicos y una fecha de aparición, que se encuentra dentro de los datos meteorológicos proporcionados. Devolverá un marco de datos de la intensidad de la enfermedad durante la temporada y otros valores asociados con el modelo. Consulte el archivo de ayuda de SEIR () para obtener más información sobre los valores devueltos. # Predict bacterial blight intensity for the year 2000 wet season at IRRI bb_wet &lt;- predict_bacterial_blight(wth, emergence = &quot;2000-07-01&quot;) Vemos los resultados de la funcion anterior: bb_wet Graficos con ggplot2 Los datos están en un formato apaisado (wide) por defecto y deben convertirse a formato largo (long) para usarlos en ggplot2 si desea graficar más de una variable a la vez. El modelo registra la cantidad de sitios para cada status a escala diaria; esto se puede graficar de la siguiente manera. bb_wet %&gt;% pivot_longer( cols = c(&quot;diseased&quot;, &quot;removed&quot;, &quot;latent&quot;, &quot;infectious&quot;), names_to = &quot;site&quot;, values_to = &quot;value&quot;) %&gt;% ggplot()+ aes(x = dates, y = value, shape = site, linetype = site) + labs(y = &quot;Sites&quot;, x = &quot;Date&quot;, title = &quot;Bacterial blight&quot;) + geom_line(aes(group = site, colour = site)) + geom_point(aes(colour = site)) + theme_classic() -&gt; p1 p1 4.2 Predict leaf blast - wet season lb_wet &lt;- predict_leaf_blast(wth, emergence = &quot;2000-07-01&quot;) lb_wet lb_wet %&gt;% pivot_longer( cols = c(&quot;diseased&quot;, &quot;removed&quot;, &quot;latent&quot;, &quot;infectious&quot;), names_to = &quot;site&quot;, values_to = &quot;value&quot;) %&gt;% ggplot() + aes(x = dates,y = value,shape = site, linetype = site) + labs(y = &quot;Sites&quot;, x = &quot;Date&quot;, title= &quot;Leaf blast&quot;) + geom_line(aes(group = site, colour = site)) + geom_point(aes(colour = site)) + theme_classic() -&gt; p2 Cargamos el paquete patchwork que nos permite organizar plots individuales library(patchwork) vemos como colecta las leyendas de ambos graficos y se usa un titulo en comun p1 + p2 + plot_annotation(title = &#39;Wet season&#39;)+ plot_layout(guides = &quot;collect&quot;) &amp; theme(legend.position = &#39;bottom&#39;) Graficar la intensidad a lo largo del tiempo no requiere ninguna manipulación de datos. bb_wet %&gt;% ggplot() %&gt;% aes(x = dates, y = intensity) + labs(y = &quot;Intensity (%)&quot;, x = &quot;Date&quot;) + geom_line() + geom_point() + theme_classic() 4.3 Comparando epidemias La forma más común de comparar epidemias de enfermedades en epidemiología botánica es utilizar el área bajo la curva del progreso de la enfermedad (AUDPC) (Shaner y Finney 1977). Esto se calcula fácilmente a partir de la salida de cualquiera de la familia de funciones predict _ () o una ejecución personalizada de SEIR () usando el paquete epifitter (Alves y Del Ponte 2020). Cargue epifitter y simule la intensidad de la enfermedad en la estación seca a partir de enero para comparar con los resultados iniciales de “bb_wet”. library(&quot;epifitter&quot;) bb_dry &lt;- predict_bacterial_blight(wth = wth, emergence = &quot;2000-01-05&quot;) bb_dry Estación seca Verifique la curva de progreso de la enfermedad para la estación seca bb_dry %&gt;% ggplot()+ aes(x = dates, y = intensity) + labs(y = &quot;Intensity (%)&quot;, x = &quot;Date&quot;) + geom_line() + geom_point() + theme_classic() Calcule el AUDPC usando el AUDPC () de epifitter para ambas temporadas y compare # Dry season AUDPC( time = bb_dry$simday, y = bb_dry$intensity, y_proportion = FALSE, type = &quot;absolute&quot;) # Wet season AUDPC( time = bb_wet$simday, y = bb_wet$intensity, y_proportion = FALSE, type = &quot;absolute&quot; ) El AUDPC de la estación húmeda es mayor que el de la estación seca. Por lo tanto, esto cumple con las expectativas de que el AUDPC de la temporada de lluvias es más alto que la temporada seca, que se pronosticó que tendría una menor intensidad de la enfermedad. Referencias Kaique dos S. Alves and Emerson M. Del Ponte (2020). epifitter: Analysis and Simulation of Plant Disease Progress Curves. R package version 0.2.0. URL: https://CRAN.R-project.org/package=epifitter. Serge Savary, Andrew Nelson, Laetitia Willocquet, Ireneo Pangga and Jorrel Aunario. Modeling and mapping potential epidemics of rice diseases globally. Crop Protection, Volume 34, 2012, Pages 6-17, ISSN 0261-2194 DOI: 10.1016/j.cropro.2011.11.009. Gregory Shaner and R. E. Finney. \"The effect of nitrogen fertilization on the expression of slow-mildewing resistance in Knox wheat. Phytopathology Volume 67.8, 1977, Pages 1051-1056. Adam Sparks (2018). nasapower: A NASA POWER Global Meteorology, Surface Solar Energy and Climatology Data Client for R. Journal of Open Source Software, 3(30), 1035, DOI: 10.21105/joss.01035. Adam Sparks (2020). nasapower: NASA-POWER Data from R. R package version 3.0.1, URL: https://CRAN.R-project.org/package=nasapower. "],["2_2-epicrop_ej.html", "5 Hands on with epicrop 5.1 Exercise 1 5.2 Exercise 2 5.3 Exercise 3 5.4 Exercise 4 5.5 Exercise 5", " 5 Hands on with epicrop We have seen how the “EPIRICE” model works and discussed the theory behind the SEIR model that drives it. Now we will work with the R package and examine some of these different factors to gain a better understanding of how the model works. The SEIR() function The SEIR() function drives the EPIRICE model. You can view the code on GitHub in the epicrop repository, https://github.com/adamhsparks/epicrop/blob/main/R/SEIR.R. If we look at the help file for SEIR() it will tell us how to use it. library(&quot;epicrop&quot;) ?SEIR() The parameters wth The first parameter, wth, is a data.frame object of weather to drive the model. epicrop has relatively simple needs for weather to run the model. Daily temperature, relative humidity and rainfall are all that are required. epicrop has a built-in function, get_wth() that will automatically fetch and format the weather data for use in SEIR() (or any of the other specialised functions for modelling disease) from two possible databases. The default database is the NASA POWER API, https://power.larc.nasa.gov. The optional database is the CHIRPS and CHIRTS APIs, https://chc.ucsb.edu/data. emergence The date that the crop emerges, or if transplanted rice, is transplanted. onset The expected number of days until the onset of disease after emergence date (day, integer). Described in Table 1 of Savary et al. 2012. duration Simulation duration i.e., growing season length (day, integer). Described in Table 1 of Savary et al. 2012. rhlim Relative humidity value threshold to decide whether leaves are wet or not (numeric). Savary et al. 2012 used 90%. rainlim Rainfall amount (mm) threshold to decide whether leaves are wet or not (numeric). Savary et al. 2012 used 5mm. H0 Initial number of plant’s healthy sites (integer). Described in Table 1 of Savary et al. 2012. I0 Initial number of infective sites (integer). Described in Table 1 of Savary et al. 2012. RcA Modifier for Rc (the basic infection rate corrected for removals) for crop age (numeric vector). Described in Table 1 of Savary et al. 2012. RcT Modifier for Rc (the basic infection rate corrected for removals) for temperature (numeric vector). Described in Table 1 of Savary et al. 2012. RcOpt Potential basic infection rate corrected for removals (numeric). Derived from Table 1 of Savary et al. 2012. i Duration of infectious period (day, integer). Described in Table 1 of Savary et al. 2012. p Duration of latent period (day, integer). Described in Table 1 of Savary et al. 2012. Sx The maximum number of sites (integer). Described in Table 1 of Savary et al. 2012. a The aggregation coefficient, values are from 1 to &gt;1 (numeric). Described in Table 1 of Savary et al. 2012. RRS Relative rate of physiological senescence (numeric). Described in Table 1 of Savary et al. 2012. RRG Relative rate of growth (numeric). Described in Table 1 of Savary et al. 2012. The “predict” family of functions Currently epicrop provides five pre-parameterised functions to predict rice diseases. These functions are the EPICROP model as published by Savary et al. 2012. predict_bacterial_blight(), predict_brown_spot(), predict_leaf_blast(), predict_sheath_blight(), and predict_tungro() You can view the help file for any of them using the same as above, ?predict_bacterial_blight. Using the “predict” functions I have attempted to make it as simple as possible to use these functions and generate model outputs. Modelling and plotting the disease progress over time for bacterial leaf blight is as follows. # get weather for IRRI Zeigler Experiment Station in wet season 2000 wth &lt;- get_wth( lonlat = c(121.25562, 14.6774), dates = c(&quot;2000-06-30&quot;, &quot;2000-12-31&quot;), source = &quot;chirps&quot; ) bb &lt;- predict_bacterial_blight(wth, emergence = &quot;2000-07-01&quot;) plot(x = bb$dates, y = bb$intensity, type = &quot;l&quot;) However, right now the POWER data’s precipitation is corrupted and CHRIPS/CHIRTS are very slow to respond. So, we’ll use some CHIRPS/CHIRTS data that I downloaded for us to use in these exercises. These data are for the IRRI Zeigler Experiment Station in Los Baños, Philippines for 2000 and 2001. # load them in your R session chirps &lt;- readRDS(&quot;chirps.rds&quot;) # inspect head(chirps) bb_wet &lt;- predict_bacterial_blight(chirps, emergence = &quot;2000-07-01&quot;) plot(x = bb_wet$dates, y = bb_wet$intensity, type = &quot;l&quot;) Differences in the five functions If you look at the code for the five functions, you will see that they each have their own values for the parameters found in SEIR(). All of the functions can be found in the GitHub repository, https://github.com/adamhsparks/epicrop/tree/main/R. We will look at predict_bacterial_blight() first. On line 92 we see that the age_coef_rc is set up as: age_coef_rc &lt;- cbind(0:12 * 10, c(1, 1, 1, 0.9, 0.62, 0.43, 0.41, 0.42, 0.41, 0.41, 0.41, 0.41, 0.41)) and the temp_coef_rc is set up as: temp_coef_rc &lt;- cbind(16 + (0:8 * 3), c(0, 0.29, 0.44, 0.90, 0.90, 1.0, 0.88, 0.01, 0)) These values are used in the RcA and RcT parameters of SEIR() to modify the disease’s progress. I find it easier to think about how this affects the model by visualising what this is creating. plot(x = age_coef_rc[, 1], y = age_coef_rc[, 2], main = &quot;BB age_coef_rc&quot;) plot(x = temp_coef_rc[, 1], y = temp_coef_rc[, 2], main = &quot;BB temp_coef_rc&quot;) 5.1 Exercise 1 Now, you compare these curves with the curves for leaf blast and answer the following questions. How do they differ? What does this imply about the pathogens and diseases that they cause? Now compare one of the other disease models’ curves with these two and see how they differ. All of the code for the disease models are available here. RcOpt We saw RcOpt in the presentation. It is the reference potential value of the basic infection rate corrected for removals for each disease. The default value for predict_bacterial_blight() is 0.87 while for predict_leaf_blast() it is 1.14. 5.2 Exercise 2 Discuss how this value changing affects the disease progress. What does a higher or lower value for RcOpt mean? H0, I0 and Sx Consider the H0 and I0 parameters for the different diseases. The model works for several types of disease, leaf area, whole leaf, tiller, whole plant all in a 1m^2 area. 5.3 Exercise 3 What are H0, I0 and Sx? How are they related? Consider how these values might differ between the functions/diseases. Explain how/why these values differ. a. Are there other scales or plant organs that you would consider if you were adding new diseases? b. What disease would these be (does not have to be rice)? c. What might the default value be for the new disease? p We did not see p, per se in the presentation but we did cover the idea of latent and infectious sites. p controls the latent period, that is how long a site remains in the E (exposed) state of SEIR before becoming infectious. 5.4 Exercise 4 Compare and contrast the different values for p from each of the predict functions. What does this tell you about the pathogens’ life-cycle and reproductive strategies? Which one has the shortest latent period? Which one has the longest latent period? RRS and RRG The last parameters in the model are RRS and RRG, or the relative rate of senescence and the relative rate of growth. Both of these parameters relate to the crop itself. Compare the values found in the different predict functions. Which are different and which are the same? How would changing these values affect the rate of disease progress? Working with epicrop outputs SEIR() produces data tables that start on day 0, establishment or emergence and progress to the end of the season, duration. By default in the predict functions, this is 120 days for a 120 day rice crop. There are 16 possible columns, 14 will always be returned with lat and lon optionally returned if provided in the wth weather input object. Any values calculated by the model are available at the end of the run. Description of fields and values from SEIR() output 1 simday Zero indexed day of simulation that was run 2 dates Date of simulation 3 sites Total number of sites present on day “x” 4 latent Number of latent sites present on day “x” 5 infectious Number of infectious sites present on day “x” 6 removed Number of removed sites present on day “x” 7 senesced Number of senesced sites present on day “x” 8 ratinf Rate of infection 9 rtransfer Rate of transfer from latent to infectious sites 10 rgrowth Rate of growth of healthy sites 11 rsenesced Rate of senescence of healthy sites 12 rlex Rate of lesion expansion 13 diseased Number of diseased (latent + infectious + removed) sites on 14 intensity Proportion of diseased (latent + infectious + removed) sites per total sites not including removed sites on day “x” 15 lat Latitude value if provided by wth object 16 lon Longitude value if provided by wth object Comparing seasons Using the epifitter package (Alves and Del Ponte 2021) we can calculate the area under the disease progress curve (AUDPC) and compare disease progress in different seasons of the same year. if (!require(&quot;epifitter&quot;)) install.packages(&quot;epifitter&quot;) library(&quot;epifitter&quot;) The data are already loaded. chirps So we can proceed running the bacterial blight model for the dry season in the same location. To do this, all that is necessary is to change the emergence date to January 1, 2000, which corresponds to a 120 day growing season that starts in the dry season. bb_dry &lt;- predict_bacterial_blight(chirps, emergence = &quot;2000-01-01&quot;) plot(x = bb_dry$dates, y = bb_dry$intensity, type = &quot;l&quot;) 5.4.1 Calculating AUDPC # wet season AUDPC( time = bb_wet$simday, y = bb_wet$intensity, y_proportion = FALSE, type = &quot;absolute&quot; ) # dry season AUDPC( time = bb_dry$simday, y = bb_dry$intensity, y_proportion = FALSE, type = &quot;absolute&quot; ) The AUDPC of the wet season is greater than that of the dry season. So, this meets the expectations that the wet season AUDPC is higher than the dry season, which for bacterial blight makes sense as the pathogen needs leaf moisture and wind to move, infect and reproduce. 5.5 Exercise 5 Explore different emergence dates to find a date with a higher or lower AUDPC than the current wet and dry season values. There are two years of weather data in the chirps data that I’ve provided starting from 2000-01-01 to 2001-12-31, which allows for several establishment dates to be compared. Explore the AUDPC for the other diseases in epicrop. Which ones are worse in the wet season and which are worse in the dry season, do some not show as much difference between seasons? "]]
